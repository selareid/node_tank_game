<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Multiplayer Thingy</title>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://code.jquery.com/jquery-1.11.1.js"></script>
    <script src="/Constants.js"></script>
    <script src="/draws.js"></script>
    <script src="/collisions.js"></script>
    <script>
        var socket = io();
        let userId;

        socket.on('userId', function (d) {
            console.log('user id ' + d);
            userId = d;
        });

        socket.on('disconnect', function () {
            console.log('disconnected from server');
            document.body.innerHTML = "SERVER DISCONNECTED <br> ATTEMPTING RECONNECT";
            window.location.reload();
        });
    </script>
</head>
<body style="background-color: #ffffff">
    <div id="playArea" style="background-color: #f8f8f8; float: left;"></div>
    <div id="sideBar" style="float: left; width:max-content; height: auto; padding-left: 25px;">
        <p id="time">____</p>
        <p id="userListP"></p>
    </div>
</body>
<script>
    //grid width and height
    // let bw = 200;
    // let bh = 200;

    //padding around grid
    let p = 15;

    //size of canvas
    // let cw = bw*5 + (p * 2) + 1;
    // let ch = bh*5 + (p * 2) + 1;
    let cw = window.innerWidth*0.75;
    let ch = window.innerHeight*0.9;

    let bw = cw / 5 - (p * 2) - 1;
    let bh = ch / 5 - (p * 2) - 1;

    let canvas = $('<canvas/>').attr({id: "mainCanvas", width: cw, height: ch}).appendTo($('#playArea'));
    let context = canvas.get(0).getContext("2d");

    let options = {
        track: true
    };

    let worldInfo;
    let localUserList = {};
    let localGameStateLatest = {};
    let topLeftPos = {x: 0, y: 0};
    let keysDown = {};

    socket.on('worldInfo', function (givenWorldInfo) {
        localGameStateLatest.terrain = givenWorldInfo.terrain;
        worldInfo = givenWorldInfo;
        delete worldInfo.terrain;

        drawBoard();

        let mouseButtonDown = false;

        //attach mouse events start
        document.getElementById('mainCanvas').addEventListener('mousedown', function (event) {
            if (event.button === 0) mouseButtonDown = true;
        });

        document.addEventListener('mouseup', function (event) {
            if (event.button === 0) mouseButtonDown = false;
        });

        document.getElementById('mainCanvas').addEventListener('mousemove', function (event) {
            if (!mouseButtonDown) return;
            topLeftPos.x -= Math.floor(event.movementX*1000/5)/1000;
            topLeftPos.y -= Math.floor(event.movementY*1000/5)/1000;
            drawBoard();
        });
        //attach mouse events end

        //attach key press event
        document.addEventListener("keydown", event => {
            if (event.isComposing || event.keyCode === 229) return; //from example code - idk
            if (event.keyCode === 87 || event.keyCode === 83 || event.keyCode ===  68 || event.keyCode ===  65) keysDown[event.keyCode] = true;
        });

        document.addEventListener("keyup", event => {
            if (event.isComposing || event.keyCode === 229) return; //from example code - idk
            if (event.keyCode === 87 || event.keyCode === 83 || event.keyCode ===  68 || event.keyCode ===  65) keysDown[event.keyCode] = false; //TODO maybe cause memory leak ;)
        });


        socket.emit('getUserList');
        socket.on('userList', function (ul) {
            if (!userId) socket.emit('getUserList'); //who am I not received yet
            //if first load of list this session, center on player
            if (Object.keys(localUserList).length === 0) {
                localUserList = ul;
                center(false);
            }
            else localUserList = ul;

            drawBoard();
            updateSideBar();
        });

        socket.on('terrain', function (terrainData) {
            localGameStateLatest.terrain = terrainData;
        });

        let lastTickStart;
        let timeSinceLastTick;

        socket.on('gameState', function (data) {
            if (lastTickStart) timeSinceLastTick = new Date() - lastTickStart;
            lastTickStart = new Date();

            //do key things
            for (let keyCode in keysDown) {
                if (!keysDown[keyCode]) continue;

                switch(parseInt(keyCode)) { //deprecated, yet supported
                    case 87: //w
                        move(0, -1); // up
                        break;
                    case 83: //s
                        move(0, 1); // down
                        break;
                    case 68: //d
                        move(1, 0); // right
                        break;
                    case 65: //a
                        move(-1, 0); // left
                        break;
                }
            }

            if (data.terrain === null || data.terrain === undefined) {
                if (localGameStateLatest.terrain === null || localGameStateLatest.terrain === undefined) socket.emit('getTerrain');
                else data.terrain = localGameStateLatest.terrain;
            }

            localGameStateLatest = data;

            //draw things last
            $('#time').text(data.time + ' ' + Math.round(1000/timeSinceLastTick));
            drawBoard(); //draw play field again, don't need to do sidebar cause players not updates
            //TODO maybe update sidebar once added player things
        }); //TODO TODO entities n things
    });

    socket.on('userDisconnected', function (disconnectedId) {
        delete localUserList[disconnectedId];
        drawBoard();
        updateSideBar();
    });

    function move(x, y) {
        if (moveCollidingWithTerrain(x, y) //entity collision checks
        || (Math.abs(localUserList[userId].position.x + x) + Constants.PLAYER_SIZE / 2 > worldInfo.width / 2 //world edge collision checks
                || Math.abs(localUserList[userId].position.y + y) + Constants.PLAYER_SIZE / 2 > worldInfo.height / 2)) {
            if (Math.abs(x) >= 1 || Math.abs(y) >= 1) move(x === 0 ? 0 : (x > 0 ? 0.1 : -0.1), y === 0 ? 0 : (y > 0 ? 0.1 : -0.1)); //retry with smaller to get as close as allowed (not stuck 0.9 away cause move is 1)
            return;
        }

        localUserList[userId].position = {
            x: localUserList[userId].position.x + x,
            y: localUserList[userId].position.y + y
        };

        //round to 2 decimal places
        localUserList[userId].position.x = Math.round(localUserList[userId].position.x * 100) / 100;
        localUserList[userId].position.y = Math.round(localUserList[userId].position.y * 100) / 100;

        drawBoard();
        updateSideBar();
        socket.emit('userMove', localUserList[userId].position);
        if (options.track) center();
    }

    socket.on('userMoved', (info) => {
        localUserList[info.id].position = info.position;
        updateSideBar();
        drawBoard();

        if (options.track && info.id === userId) center();
    });
</script>
</html>